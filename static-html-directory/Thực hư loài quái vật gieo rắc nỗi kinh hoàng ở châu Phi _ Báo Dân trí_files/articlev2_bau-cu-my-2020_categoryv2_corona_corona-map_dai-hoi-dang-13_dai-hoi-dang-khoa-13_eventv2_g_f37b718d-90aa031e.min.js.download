(window.WssBaomoiWebJsonp=window.WssBaomoiWebJsonp||[]).push([[1],{410:function(e,t,n){n(9)(n(624))},411:function(e,t,n){n(9)(n(625))},624:function(e,t,n){e.exports="// extracted by mini-css-extract-plugin"},625:function(e,t){e.exports='function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\n!function ($) {\n  var apiParams = {\n    set: {\n      colors: 1,\n      values: 1,\n      backgroundColor: 1,\n      scaleColors: 1,\n      normalizeFunction: 1,\n      focus: 1\n    },\n    get: {\n      selectedRegions: 1,\n      selectedMarkers: 1,\n      mapObject: 1,\n      regionName: 1\n    }\n  };\n\n  $.fn.vectorMap = function (options) {\n    var map = this.children(".jvectormap-container").data("mapObject");\n    if ("addMap" === options) jvm.Map.maps[arguments[1]] = arguments[2];else {\n      if (("set" === options || "get" === options) && apiParams[options][arguments[1]]) return map[options + (arguments[1].charAt(0).toUpperCase() + arguments[1].substr(1))].apply(map, Array.prototype.slice.call(arguments, 2));\n      (options = options || {}).container = this, map = new jvm.Map(options);\n    }\n    return this;\n  };\n}(jQuery), function (factory) {\n  "function" == typeof define && define.amd ? define(["jquery"], factory) : "object" == (typeof exports === "undefined" ? "undefined" : _typeof(exports)) ? module.exports = factory : factory(jQuery);\n}(function ($) {\n  var nullLowestDeltaTimeout,\n      lowestDelta,\n      toFix = ["wheel", "mousewheel", "DOMMouseScroll", "MozMousePixelScroll"],\n      toBind = "onwheel" in document || 9 <= document.documentMode ? ["wheel"] : ["mousewheel", "DomMouseScroll", "MozMousePixelScroll"],\n      slice = Array.prototype.slice;\n  if ($.event.fixHooks) for (var i = toFix.length; i;) {\n    $.event.fixHooks[toFix[--i]] = $.event.mouseHooks;\n  }\n  var special = $.event.special.mousewheel = {\n    version: "3.1.9",\n    setup: function setup() {\n      if (this.addEventListener) for (var i = toBind.length; i;) {\n        this.addEventListener(toBind[--i], handler, !1);\n      } else this.onmousewheel = handler;\n      $.data(this, "mousewheel-line-height", special.getLineHeight(this)), $.data(this, "mousewheel-page-height", special.getPageHeight(this));\n    },\n    teardown: function teardown() {\n      if (this.removeEventListener) for (var i = toBind.length; i;) {\n        this.removeEventListener(toBind[--i], handler, !1);\n      } else this.onmousewheel = null;\n    },\n    getLineHeight: function getLineHeight(elem) {\n      return parseInt($(elem)["offsetParent" in $.fn ? "offsetParent" : "parent"]().css("fontSize"), 10);\n    },\n    getPageHeight: function getPageHeight(elem) {\n      return $(elem).height();\n    },\n    settings: {\n      adjustOldDeltas: !0\n    }\n  };\n\n  function handler(event) {\n    var absDelta,\n        orgEvent = event || window.event,\n        args = slice.call(arguments, 1),\n        delta = 0,\n        deltaX = 0,\n        deltaY = 0;\n\n    if ((event = $.event.fix(orgEvent)).type = "mousewheel", "detail" in orgEvent && (deltaY = -1 * orgEvent.detail), "wheelDelta" in orgEvent && (deltaY = orgEvent.wheelDelta), "wheelDeltaY" in orgEvent && (deltaY = orgEvent.wheelDeltaY), "wheelDeltaX" in orgEvent && (deltaX = -1 * orgEvent.wheelDeltaX), "axis" in orgEvent && orgEvent.axis === orgEvent.HORIZONTAL_AXIS && (deltaX = -1 * deltaY, deltaY = 0), delta = 0 === deltaY ? deltaX : deltaY, "deltaY" in orgEvent && (delta = deltaY = -1 * orgEvent.deltaY), "deltaX" in orgEvent && (deltaX = orgEvent.deltaX, 0 === deltaY && (delta = -1 * deltaX)), 0 !== deltaY || 0 !== deltaX) {\n      if (1 === orgEvent.deltaMode) {\n        var lineHeight = $.data(this, "mousewheel-line-height");\n        delta *= lineHeight, deltaY *= lineHeight, deltaX *= lineHeight;\n      } else if (2 === orgEvent.deltaMode) {\n        var pageHeight = $.data(this, "mousewheel-page-height");\n        delta *= pageHeight, deltaY *= pageHeight, deltaX *= pageHeight;\n      }\n\n      return absDelta = Math.max(Math.abs(deltaY), Math.abs(deltaX)), (!lowestDelta || absDelta < lowestDelta) && shouldAdjustOldDeltas(orgEvent, lowestDelta = absDelta) && (lowestDelta /= 40), shouldAdjustOldDeltas(orgEvent, absDelta) && (delta /= 40, deltaX /= 40, deltaY /= 40), delta = Math[1 <= delta ? "floor" : "ceil"](delta / lowestDelta), deltaX = Math[1 <= deltaX ? "floor" : "ceil"](deltaX / lowestDelta), deltaY = Math[1 <= deltaY ? "floor" : "ceil"](deltaY / lowestDelta), event.deltaX = deltaX, event.deltaY = deltaY, event.deltaFactor = lowestDelta, event.deltaMode = 0, args.unshift(event, delta, deltaX, deltaY), nullLowestDeltaTimeout && clearTimeout(nullLowestDeltaTimeout), nullLowestDeltaTimeout = setTimeout(nullLowestDelta, 200), ($.event.dispatch || $.event.handle).apply(this, args);\n    }\n  }\n\n  function nullLowestDelta() {\n    lowestDelta = null;\n  }\n\n  function shouldAdjustOldDeltas(orgEvent, absDelta) {\n    return special.settings.adjustOldDeltas && "mousewheel" === orgEvent.type && absDelta % 120 == 0;\n  }\n\n  $.fn.extend({\n    mousewheel: function mousewheel(fn) {\n      return fn ? this.bind("mousewheel", fn) : this.trigger("mousewheel");\n    },\n    unmousewheel: function unmousewheel(fn) {\n      return this.unbind("mousewheel", fn);\n    }\n  });\n});\nvar jvm = {\n  inherits: function inherits(child, parent) {\n    function temp() {}\n\n    temp.prototype = parent.prototype, child.prototype = new temp(), (child.prototype.constructor = child).parentClass = parent;\n  },\n  mixin: function mixin(target, source) {\n    var prop;\n\n    for (prop in source.prototype) {\n      source.prototype.hasOwnProperty(prop) && (target.prototype[prop] = source.prototype[prop]);\n    }\n  },\n  min: function min(values) {\n    var i,\n        min = Number.MAX_VALUE;\n    if (values instanceof Array) for (i = 0; i < values.length; i++) {\n      values[i] < min && (min = values[i]);\n    } else for (i in values) {\n      values[i] < min && (min = values[i]);\n    }\n    return min;\n  },\n  max: function max(values) {\n    var i,\n        max = Number.MIN_VALUE;\n    if (values instanceof Array) for (i = 0; i < values.length; i++) {\n      values[i] > max && (max = values[i]);\n    } else for (i in values) {\n      values[i] > max && (max = values[i]);\n    }\n    return max;\n  },\n  keys: function keys(object) {\n    var key,\n        keys = [];\n\n    for (key in object) {\n      keys.push(key);\n    }\n\n    return keys;\n  },\n  values: function values(object) {\n    var key,\n        i,\n        values = [];\n\n    for (i = 0; i < arguments.length; i++) {\n      for (key in object = arguments[i]) {\n        values.push(object[key]);\n      }\n    }\n\n    return values;\n  },\n  whenImageLoaded: function whenImageLoaded(url) {\n    var deferred = new jvm.$.Deferred(),\n        img = jvm.$("<img/>");\n    return img.on("error", function () {\n      deferred.reject();\n    }).on("load", function () {\n      deferred.resolve(img);\n    }), img.attr("src", url), deferred;\n  },\n  isImageUrl: function isImageUrl(s) {\n    return /\\.\\w{3,4}$/.test(s);\n  }\n};\njvm.$ = jQuery, Array.prototype.indexOf || (Array.prototype.indexOf = function (searchElement, fromIndex) {\n  var k;\n  if (null == this) throw new TypeError(\'"this" is null or not defined\');\n  var O = Object(this),\n      len = O.length >>> 0;\n  if (0 == len) return -1;\n  var n = +fromIndex || 0;\n  if (Math.abs(n) === 1 / 0 && (n = 0), len <= n) return -1;\n\n  for (k = Math.max(0 <= n ? n : len - Math.abs(n), 0); k < len;) {\n    if (k in O && O[k] === searchElement) return k;\n    k++;\n  }\n\n  return -1;\n}), jvm.AbstractElement = function (name, config) {\n  this.node = this.createElement(name), this.name = name, this.properties = {}, config && this.set(config);\n}, jvm.AbstractElement.prototype.set = function (property, value) {\n  var key;\n  if ("object" == _typeof(property)) for (key in property) {\n    this.properties[key] = property[key], this.applyAttr(key, property[key]);\n  } else this.properties[property] = value, this.applyAttr(property, value);\n}, jvm.AbstractElement.prototype.get = function (property) {\n  return this.properties[property];\n}, jvm.AbstractElement.prototype.applyAttr = function (property, value) {\n  this.node.setAttribute(property, value);\n}, jvm.AbstractElement.prototype.remove = function () {\n  jvm.$(this.node).remove();\n}, jvm.AbstractCanvasElement = function (container, width, height) {\n  this.container = container, this.setSize(width, height), this.rootElement = new jvm[this.classPrefix + "GroupElement"](), this.node.appendChild(this.rootElement.node), this.container.appendChild(this.node);\n}, jvm.AbstractCanvasElement.prototype.add = function (element, group) {\n  (group = group || this.rootElement).add(element), element.canvas = this;\n}, jvm.AbstractCanvasElement.prototype.addPath = function (config, style, group) {\n  var el = new jvm[this.classPrefix + "PathElement"](config, style);\n  return this.add(el, group), el;\n}, jvm.AbstractCanvasElement.prototype.addCircle = function (config, style, group) {\n  var el = new jvm[this.classPrefix + "CircleElement"](config, style);\n  return this.add(el, group), el;\n}, jvm.AbstractCanvasElement.prototype.addImage = function (config, style, group) {\n  var el = new jvm[this.classPrefix + "ImageElement"](config, style);\n  return this.add(el, group), el;\n}, jvm.AbstractCanvasElement.prototype.addText = function (config, style, group) {\n  var el = new jvm[this.classPrefix + "TextElement"](config, style);\n  return this.add(el, group), el;\n}, jvm.AbstractCanvasElement.prototype.addGroup = function (parentGroup) {\n  var el = new jvm[this.classPrefix + "GroupElement"]();\n  return parentGroup ? parentGroup.node.appendChild(el.node) : this.node.appendChild(el.node), el.canvas = this, el;\n}, jvm.AbstractShapeElement = function (name, config, style) {\n  this.style = style || {}, this.style.current = this.style.current || {}, this.isHovered = !1, this.isSelected = !1, this.updateStyle();\n}, jvm.AbstractShapeElement.prototype.setStyle = function (property, value) {\n  var styles = {};\n  "object" == _typeof(property) ? styles = property : styles[property] = value, jvm.$.extend(this.style.current, styles), this.updateStyle();\n}, jvm.AbstractShapeElement.prototype.updateStyle = function () {\n  var attrs = {};\n  jvm.AbstractShapeElement.mergeStyles(attrs, this.style.initial), jvm.AbstractShapeElement.mergeStyles(attrs, this.style.current), this.isHovered && jvm.AbstractShapeElement.mergeStyles(attrs, this.style.hover), this.isSelected && (jvm.AbstractShapeElement.mergeStyles(attrs, this.style.selected), this.isHovered && jvm.AbstractShapeElement.mergeStyles(attrs, this.style.selectedHover)), this.set(attrs);\n}, jvm.AbstractShapeElement.mergeStyles = function (styles, newStyles) {\n  var key;\n\n  for (key in newStyles = newStyles || {}) {\n    null === newStyles[key] ? delete styles[key] : styles[key] = newStyles[key];\n  }\n}, jvm.SVGElement = function (name, config) {\n  jvm.SVGElement.parentClass.apply(this, arguments);\n}, jvm.inherits(jvm.SVGElement, jvm.AbstractElement), jvm.SVGElement.svgns = "http://www.w3.org/2000/svg", jvm.SVGElement.prototype.createElement = function (tagName) {\n  return document.createElementNS(jvm.SVGElement.svgns, tagName);\n}, jvm.SVGElement.prototype.addClass = function (className) {\n  this.node.setAttribute("class", className);\n}, jvm.SVGElement.prototype.getElementCtr = function (ctr) {\n  return jvm["SVG" + ctr];\n}, jvm.SVGElement.prototype.getBBox = function () {\n  return this.node.getBBox();\n}, jvm.SVGGroupElement = function () {\n  jvm.SVGGroupElement.parentClass.call(this, "g");\n}, jvm.inherits(jvm.SVGGroupElement, jvm.SVGElement), jvm.SVGGroupElement.prototype.add = function (element) {\n  this.node.appendChild(element.node);\n}, jvm.SVGCanvasElement = function (container, width, height) {\n  this.classPrefix = "SVG", jvm.SVGCanvasElement.parentClass.call(this, "svg"), this.defsElement = new jvm.SVGElement("defs"), this.node.appendChild(this.defsElement.node), jvm.AbstractCanvasElement.apply(this, arguments);\n}, jvm.inherits(jvm.SVGCanvasElement, jvm.SVGElement), jvm.mixin(jvm.SVGCanvasElement, jvm.AbstractCanvasElement), jvm.SVGCanvasElement.prototype.setSize = function (width, height) {\n  this.width = width, this.height = height, this.node.setAttribute("width", width), this.node.setAttribute("height", height);\n}, jvm.SVGCanvasElement.prototype.applyTransformParams = function (scale, transX, transY) {\n  this.scale = scale, this.transX = transX, this.transY = transY, this.rootElement.node.setAttribute("transform", "scale(" + scale + ") translate(" + transX + ", " + transY + ")");\n}, jvm.SVGShapeElement = function (name, config, style) {\n  jvm.SVGShapeElement.parentClass.call(this, name, config), jvm.AbstractShapeElement.apply(this, arguments);\n}, jvm.inherits(jvm.SVGShapeElement, jvm.SVGElement), jvm.mixin(jvm.SVGShapeElement, jvm.AbstractShapeElement), jvm.SVGShapeElement.prototype.applyAttr = function (attr, value) {\n  var patternEl,\n      imageEl,\n      that = this;\n  "fill" === attr && jvm.isImageUrl(value) ? jvm.SVGShapeElement.images[value] ? this.applyAttr("fill", "url(#image" + jvm.SVGShapeElement.images[value] + ")") : jvm.whenImageLoaded(value).then(function (img) {\n    (imageEl = new jvm.SVGElement("image")).node.setAttributeNS("http://www.w3.org/1999/xlink", "href", value), imageEl.applyAttr("x", "0"), imageEl.applyAttr("y", "0"), imageEl.applyAttr("width", img[0].width), imageEl.applyAttr("height", img[0].height), (patternEl = new jvm.SVGElement("pattern")).applyAttr("id", "image" + jvm.SVGShapeElement.imageCounter), patternEl.applyAttr("x", 0), patternEl.applyAttr("y", 0), patternEl.applyAttr("width", img[0].width / 2), patternEl.applyAttr("height", img[0].height / 2), patternEl.applyAttr("viewBox", "0 0 " + img[0].width + " " + img[0].height), patternEl.applyAttr("patternUnits", "userSpaceOnUse"), patternEl.node.appendChild(imageEl.node), that.canvas.defsElement.node.appendChild(patternEl.node), jvm.SVGShapeElement.images[value] = jvm.SVGShapeElement.imageCounter++, that.applyAttr("fill", "url(#image" + jvm.SVGShapeElement.images[value] + ")");\n  }) : jvm.SVGShapeElement.parentClass.prototype.applyAttr.apply(this, arguments);\n}, jvm.SVGShapeElement.imageCounter = 1, jvm.SVGShapeElement.images = {}, jvm.SVGPathElement = function (config, style) {\n  jvm.SVGPathElement.parentClass.call(this, "path", config, style), this.node.setAttribute("fill-rule", "evenodd");\n}, jvm.inherits(jvm.SVGPathElement, jvm.SVGShapeElement), jvm.SVGCircleElement = function (config, style) {\n  jvm.SVGCircleElement.parentClass.call(this, "circle", config, style);\n}, jvm.inherits(jvm.SVGCircleElement, jvm.SVGShapeElement), jvm.SVGImageElement = function (config, style) {\n  jvm.SVGImageElement.parentClass.call(this, "image", config, style);\n}, jvm.inherits(jvm.SVGImageElement, jvm.SVGShapeElement), jvm.SVGImageElement.prototype.applyAttr = function (attr, value) {\n  var imageUrl,\n      that = this;\n  "image" == attr ? ("object" == _typeof(value) ? (imageUrl = value.url, this.offset = value.offset) : (imageUrl = value, this.offset = [0, 0]), jvm.whenImageLoaded(imageUrl).then(function (img) {\n    that.node.setAttributeNS("http://www.w3.org/1999/xlink", "href", imageUrl), that.width = img[0].width, that.height = img[0].height, that.applyAttr("width", that.width), that.applyAttr("height", that.height), that.applyAttr("x", that.cx - that.width / 2 + that.offset[0]), that.applyAttr("y", that.cy - that.height / 2 + that.offset[1]), jvm.$(that.node).trigger("imageloaded", [img]);\n  })) : "cx" == attr ? (this.cx = value, this.width && this.applyAttr("x", value - this.width / 2 + this.offset[0])) : "cy" == attr ? (this.cy = value, this.height && this.applyAttr("y", value - this.height / 2 + this.offset[1])) : jvm.SVGImageElement.parentClass.prototype.applyAttr.apply(this, arguments);\n}, jvm.SVGTextElement = function (config, style) {\n  jvm.SVGTextElement.parentClass.call(this, "text", config, style);\n}, jvm.inherits(jvm.SVGTextElement, jvm.SVGShapeElement), jvm.SVGTextElement.prototype.applyAttr = function (attr, value) {\n  "text" === attr ? this.node.textContent = value : jvm.SVGTextElement.parentClass.prototype.applyAttr.apply(this, arguments);\n}, jvm.VMLElement = function (name, config) {\n  jvm.VMLElement.VMLInitialized || jvm.VMLElement.initializeVML(), jvm.VMLElement.parentClass.apply(this, arguments);\n}, jvm.inherits(jvm.VMLElement, jvm.AbstractElement), jvm.VMLElement.VMLInitialized = !1, jvm.VMLElement.initializeVML = function () {\n  try {\n    document.namespaces.rvml || document.namespaces.add("rvml", "urn:schemas-microsoft-com:vml"), jvm.VMLElement.prototype.createElement = function (tagName) {\n      return document.createElement("<rvml:" + tagName + \' class="rvml">\');\n    };\n  } catch (e) {\n    jvm.VMLElement.prototype.createElement = function (tagName) {\n      return document.createElement("<" + tagName + \' xmlns="urn:schemas-microsoft.com:vml" class="rvml">\');\n    };\n  }\n\n  document.createStyleSheet().addRule(".rvml", "behavior:url(#default#VML)"), jvm.VMLElement.VMLInitialized = !0;\n}, jvm.VMLElement.prototype.getElementCtr = function (ctr) {\n  return jvm["VML" + ctr];\n}, jvm.VMLElement.prototype.addClass = function (className) {\n  jvm.$(this.node).addClass(className);\n}, jvm.VMLElement.prototype.applyAttr = function (attr, value) {\n  this.node[attr] = value;\n}, jvm.VMLElement.prototype.getBBox = function () {\n  var node = jvm.$(this.node);\n  return {\n    x: node.position().left / this.canvas.scale,\n    y: node.position().top / this.canvas.scale,\n    width: node.width() / this.canvas.scale,\n    height: node.height() / this.canvas.scale\n  };\n}, jvm.VMLGroupElement = function () {\n  jvm.VMLGroupElement.parentClass.call(this, "group"), this.node.style.left = "0px", this.node.style.top = "0px", this.node.coordorigin = "0 0";\n}, jvm.inherits(jvm.VMLGroupElement, jvm.VMLElement), jvm.VMLGroupElement.prototype.add = function (element) {\n  this.node.appendChild(element.node);\n}, jvm.VMLCanvasElement = function (container, width, height) {\n  this.classPrefix = "VML", jvm.VMLCanvasElement.parentClass.call(this, "group"), jvm.AbstractCanvasElement.apply(this, arguments), this.node.style.position = "absolute";\n}, jvm.inherits(jvm.VMLCanvasElement, jvm.VMLElement), jvm.mixin(jvm.VMLCanvasElement, jvm.AbstractCanvasElement), jvm.VMLCanvasElement.prototype.setSize = function (width, height) {\n  var paths, groups, i, l;\n\n  if (this.width = width, this.height = height, this.node.style.width = width + "px", this.node.style.height = height + "px", this.node.coordsize = width + " " + height, this.node.coordorigin = "0 0", this.rootElement) {\n    for (i = 0, l = (paths = this.rootElement.node.getElementsByTagName("shape")).length; i < l; i++) {\n      paths[i].coordsize = width + " " + height, paths[i].style.width = width + "px", paths[i].style.height = height + "px";\n    }\n\n    for (i = 0, l = (groups = this.node.getElementsByTagName("group")).length; i < l; i++) {\n      groups[i].coordsize = width + " " + height, groups[i].style.width = width + "px", groups[i].style.height = height + "px";\n    }\n  }\n}, jvm.VMLCanvasElement.prototype.applyTransformParams = function (scale, transX, transY) {\n  this.scale = scale, this.transX = transX, this.transY = transY, this.rootElement.node.coordorigin = this.width - transX - this.width / 100 + "," + (this.height - transY - this.height / 100), this.rootElement.node.coordsize = this.width / scale + "," + this.height / scale;\n}, jvm.VMLShapeElement = function (name, config) {\n  jvm.VMLShapeElement.parentClass.call(this, name, config), this.fillElement = new jvm.VMLElement("fill"), this.strokeElement = new jvm.VMLElement("stroke"), this.node.appendChild(this.fillElement.node), this.node.appendChild(this.strokeElement.node), this.node.stroked = !1, jvm.AbstractShapeElement.apply(this, arguments);\n}, jvm.inherits(jvm.VMLShapeElement, jvm.VMLElement), jvm.mixin(jvm.VMLShapeElement, jvm.AbstractShapeElement), jvm.VMLShapeElement.prototype.applyAttr = function (attr, value) {\n  switch (attr) {\n    case "fill":\n      this.node.fillcolor = value;\n      break;\n\n    case "fill-opacity":\n      this.fillElement.node.opacity = Math.round(100 * value) + "%";\n      break;\n\n    case "stroke":\n      this.node.stroked = "none" !== value, this.node.strokecolor = value;\n      break;\n\n    case "stroke-opacity":\n      this.strokeElement.node.opacity = Math.round(100 * value) + "%";\n      break;\n\n    case "stroke-width":\n      0 === parseInt(value, 10) ? this.node.stroked = !1 : this.node.stroked = !0, this.node.strokeweight = value;\n      break;\n\n    case "d":\n      this.node.path = jvm.VMLPathElement.pathSvgToVml(value);\n      break;\n\n    default:\n      jvm.VMLShapeElement.parentClass.prototype.applyAttr.apply(this, arguments);\n  }\n}, jvm.VMLPathElement = function (config, style) {\n  var scale = new jvm.VMLElement("skew");\n  jvm.VMLPathElement.parentClass.call(this, "shape", config, style), this.node.coordorigin = "0 0", scale.node.on = !0, scale.node.matrix = "0.01,0,0,0.01,0,0", scale.node.offset = "0,0", this.node.appendChild(scale.node);\n}, jvm.inherits(jvm.VMLPathElement, jvm.VMLShapeElement), jvm.VMLPathElement.prototype.applyAttr = function (attr, value) {\n  "d" === attr ? this.node.path = jvm.VMLPathElement.pathSvgToVml(value) : jvm.VMLShapeElement.prototype.applyAttr.call(this, attr, value);\n}, jvm.VMLPathElement.pathSvgToVml = function (path) {\n  var ctrlx,\n      ctrly,\n      cx = 0,\n      cy = 0;\n  return (path = path.replace(/(-?\\d+)e(-?\\d+)/g, "0")).replace(/([MmLlHhVvCcSs])\\s*((?:-?\\d*(?:\\.\\d+)?\\s*,?\\s*)+)/g, function (segment, letter, coords, index) {\n    (coords = coords.replace(/(\\d)-/g, "$1,-").replace(/^\\s+/g, "").replace(/\\s+$/g, "").replace(/\\s+/g, ",").split(","))[0] || coords.shift();\n\n    for (var i = 0, l = coords.length; i < l; i++) {\n      coords[i] = Math.round(100 * coords[i]);\n    }\n\n    switch (letter) {\n      case "m":\n        return cx += coords[0], cy += coords[1], "t" + coords.join(",");\n\n      case "M":\n        return cx = coords[0], cy = coords[1], "m" + coords.join(",");\n\n      case "l":\n        return cx += coords[0], cy += coords[1], "r" + coords.join(",");\n\n      case "L":\n        return cx = coords[0], cy = coords[1], "l" + coords.join(",");\n\n      case "h":\n        return cx += coords[0], "r" + coords[0] + ",0";\n\n      case "H":\n        return "l" + (cx = coords[0]) + "," + cy;\n\n      case "v":\n        return cy += coords[0], "r0," + coords[0];\n\n      case "V":\n        return cy = coords[0], "l" + cx + "," + cy;\n\n      case "c":\n        return ctrlx = cx + coords[coords.length - 4], ctrly = cy + coords[coords.length - 3], cx += coords[coords.length - 2], cy += coords[coords.length - 1], "v" + coords.join(",");\n\n      case "C":\n        return ctrlx = coords[coords.length - 4], ctrly = coords[coords.length - 3], cx = coords[coords.length - 2], cy = coords[coords.length - 1], "c" + coords.join(",");\n\n      case "s":\n        return coords.unshift(cy - ctrly), coords.unshift(cx - ctrlx), ctrlx = cx + coords[coords.length - 4], ctrly = cy + coords[coords.length - 3], cx += coords[coords.length - 2], cy += coords[coords.length - 1], "v" + coords.join(",");\n\n      case "S":\n        return coords.unshift(cy + cy - ctrly), coords.unshift(cx + cx - ctrlx), ctrlx = coords[coords.length - 4], ctrly = coords[coords.length - 3], cx = coords[coords.length - 2], cy = coords[coords.length - 1], "c" + coords.join(",");\n    }\n\n    return "";\n  }).replace(/z/g, "e");\n}, jvm.VMLCircleElement = function (config, style) {\n  jvm.VMLCircleElement.parentClass.call(this, "oval", config, style);\n}, jvm.inherits(jvm.VMLCircleElement, jvm.VMLShapeElement), jvm.VMLCircleElement.prototype.applyAttr = function (attr, value) {\n  switch (attr) {\n    case "r":\n      this.node.style.width = 2 * value + "px", this.node.style.height = 2 * value + "px", this.applyAttr("cx", this.get("cx") || 0), this.applyAttr("cy", this.get("cy") || 0);\n      break;\n\n    case "cx":\n      if (!value) return;\n      this.node.style.left = value - (this.get("r") || 0) + "px";\n      break;\n\n    case "cy":\n      if (!value) return;\n      this.node.style.top = value - (this.get("r") || 0) + "px";\n      break;\n\n    default:\n      jvm.VMLCircleElement.parentClass.prototype.applyAttr.call(this, attr, value);\n  }\n}, jvm.VectorCanvas = function (container, width, height) {\n  return this.mode = window.SVGAngle ? "svg" : "vml", "svg" == this.mode ? this.impl = new jvm.SVGCanvasElement(container, width, height) : this.impl = new jvm.VMLCanvasElement(container, width, height), this.impl.mode = this.mode, this.impl;\n}, jvm.SimpleScale = function (scale) {\n  this.scale = scale;\n}, jvm.SimpleScale.prototype.getValue = function (value) {\n  return value;\n}, jvm.OrdinalScale = function (scale) {\n  this.scale = scale;\n}, jvm.OrdinalScale.prototype.getValue = function (value) {\n  return this.scale[value];\n}, jvm.OrdinalScale.prototype.getTicks = function () {\n  var key,\n      ticks = [];\n\n  for (key in this.scale) {\n    ticks.push({\n      label: key,\n      value: this.scale[key]\n    });\n  }\n\n  return ticks;\n}, jvm.NumericScale = function (scale, normalizeFunction, minValue, maxValue) {\n  this.scale = [], normalizeFunction = normalizeFunction || "linear", scale && this.setScale(scale), normalizeFunction && this.setNormalizeFunction(normalizeFunction), void 0 !== minValue && this.setMin(minValue), void 0 !== maxValue && this.setMax(maxValue);\n}, jvm.NumericScale.prototype = {\n  setMin: function setMin(min) {\n    this.clearMinValue = min, "function" == typeof this.normalize ? this.minValue = this.normalize(min) : this.minValue = min;\n  },\n  setMax: function setMax(max) {\n    this.clearMaxValue = max, "function" == typeof this.normalize ? this.maxValue = this.normalize(max) : this.maxValue = max;\n  },\n  setScale: function setScale(scale) {\n    var i;\n\n    for (this.scale = [], i = 0; i < scale.length; i++) {\n      this.scale[i] = [scale[i]];\n    }\n  },\n  setNormalizeFunction: function setNormalizeFunction(f) {\n    "polynomial" === f ? this.normalize = function (value) {\n      return Math.pow(value, .2);\n    } : "linear" === f ? delete this.normalize : this.normalize = f, this.setMin(this.clearMinValue), this.setMax(this.clearMaxValue);\n  },\n  getValue: function getValue(value) {\n    var l,\n        c,\n        lengthes = [],\n        fullLength = 0,\n        i = 0;\n\n    for ("function" == typeof this.normalize && (value = this.normalize(value)), i = 0; i < this.scale.length - 1; i++) {\n      l = this.vectorLength(this.vectorSubtract(this.scale[i + 1], this.scale[i])), lengthes.push(l), fullLength += l;\n    }\n\n    for (c = (this.maxValue - this.minValue) / fullLength, i = 0; i < lengthes.length; i++) {\n      lengthes[i] *= c;\n    }\n\n    for (i = 0, value -= this.minValue; 0 <= value - lengthes[i];) {\n      value -= lengthes[i], i++;\n    }\n\n    return value = i == this.scale.length - 1 ? this.vectorToNum(this.scale[i]) : this.vectorToNum(this.vectorAdd(this.scale[i], this.vectorMult(this.vectorSubtract(this.scale[i + 1], this.scale[i]), value / lengthes[i])));\n  },\n  vectorToNum: function vectorToNum(vector) {\n    var i,\n        num = 0;\n\n    for (i = 0; i < vector.length; i++) {\n      num += Math.round(vector[i]) * Math.pow(256, vector.length - i - 1);\n    }\n\n    return num;\n  },\n  vectorSubtract: function vectorSubtract(vector1, vector2) {\n    var i,\n        vector = [];\n\n    for (i = 0; i < vector1.length; i++) {\n      vector[i] = vector1[i] - vector2[i];\n    }\n\n    return vector;\n  },\n  vectorAdd: function vectorAdd(vector1, vector2) {\n    var i,\n        vector = [];\n\n    for (i = 0; i < vector1.length; i++) {\n      vector[i] = vector1[i] + vector2[i];\n    }\n\n    return vector;\n  },\n  vectorMult: function vectorMult(vector, num) {\n    var i,\n        result = [];\n\n    for (i = 0; i < vector.length; i++) {\n      result[i] = vector[i] * num;\n    }\n\n    return result;\n  },\n  vectorLength: function vectorLength(vector) {\n    var i,\n        result = 0;\n\n    for (i = 0; i < vector.length; i++) {\n      result += vector[i] * vector[i];\n    }\n\n    return Math.sqrt(result);\n  },\n  getTicks: function getTicks() {\n    var tick,\n        v,\n        extent = [this.clearMinValue, this.clearMaxValue],\n        span = extent[1] - extent[0],\n        step = Math.pow(10, Math.floor(Math.log(span / 5) / Math.LN10)),\n        err = 5 / span * step,\n        ticks = [];\n\n    for (err <= .15 ? step *= 10 : err <= .35 ? step *= 5 : err <= .75 && (step *= 2), extent[0] = Math.floor(extent[0] / step) * step, extent[1] = Math.ceil(extent[1] / step) * step, tick = extent[0]; tick <= extent[1];) {\n      v = tick == extent[0] ? this.clearMinValue : tick == extent[1] ? this.clearMaxValue : tick, ticks.push({\n        label: tick,\n        value: this.getValue(v)\n      }), tick += step;\n    }\n\n    return ticks;\n  }\n}, jvm.ColorScale = function (colors, normalizeFunction, minValue, maxValue) {\n  jvm.ColorScale.parentClass.apply(this, arguments);\n}, jvm.inherits(jvm.ColorScale, jvm.NumericScale), jvm.ColorScale.prototype.setScale = function (scale) {\n  var i;\n\n  for (i = 0; i < scale.length; i++) {\n    this.scale[i] = jvm.ColorScale.rgbToArray(scale[i]);\n  }\n}, jvm.ColorScale.prototype.getValue = function (value) {\n  return jvm.ColorScale.numToRgb(jvm.ColorScale.parentClass.prototype.getValue.call(this, value));\n}, jvm.ColorScale.arrayToRgb = function (ar) {\n  var d,\n      i,\n      rgb = "#";\n\n  for (i = 0; i < ar.length; i++) {\n    rgb += 1 == (d = ar[i].toString(16)).length ? "0" + d : d;\n  }\n\n  return rgb;\n}, jvm.ColorScale.numToRgb = function (num) {\n  for (num = num.toString(16); num.length < 6;) {\n    num = "0" + num;\n  }\n\n  return "#" + num;\n}, jvm.ColorScale.rgbToArray = function (rgb) {\n  return rgb = rgb.substr(1), [parseInt(rgb.substr(0, 2), 16), parseInt(rgb.substr(2, 2), 16), parseInt(rgb.substr(4, 2), 16)];\n}, jvm.Legend = function (params) {\n  this.params = params || {}, this.map = this.params.map, this.series = this.params.series, this.body = jvm.$("<div/>"), this.body.addClass("jvectormap-legend"), this.params.cssClass && this.body.addClass(this.params.cssClass), params.vertical ? this.map.legendCntVertical.append(this.body) : this.map.legendCntHorizontal.append(this.body), this.render();\n}, jvm.Legend.prototype.render = function () {\n  var i,\n      tick,\n      sample,\n      label,\n      ticks = this.series.scale.getTicks(),\n      inner = jvm.$("<div/>").addClass("jvectormap-legend-inner");\n\n  for (this.body.html(""), this.params.title && this.body.append(jvm.$("<div/>").addClass("jvectormap-legend-title").html(this.params.title)), this.body.append(inner), i = 0; i < ticks.length; i++) {\n    switch (tick = jvm.$("<div/>").addClass("jvectormap-legend-tick"), sample = jvm.$("<div/>").addClass("jvectormap-legend-tick-sample"), this.series.params.attribute) {\n      case "fill":\n        jvm.isImageUrl(ticks[i].value) ? sample.css("background", "url(" + ticks[i].value + ")") : sample.css("background", ticks[i].value);\n        break;\n\n      case "stroke":\n        sample.css("background", ticks[i].value);\n        break;\n\n      case "image":\n        sample.css("background", "url(" + ("object" == _typeof(ticks[i].value) ? ticks[i].value.url : ticks[i].value) + ") no-repeat center center");\n        break;\n\n      case "r":\n        jvm.$("<div/>").css({\n          "border-radius": ticks[i].value,\n          border: this.map.params.markerStyle.initial["stroke-width"] + "px " + this.map.params.markerStyle.initial.stroke + " solid",\n          width: 2 * ticks[i].value + "px",\n          height: 2 * ticks[i].value + "px",\n          background: this.map.params.markerStyle.initial.fill\n        }).appendTo(sample);\n    }\n\n    tick.append(sample), label = ticks[i].label, this.params.labelRender && (label = this.params.labelRender(label)), tick.append(jvm.$("<div>" + label + " </div>").addClass("jvectormap-legend-tick-text")), inner.append(tick);\n  }\n\n  inner.append(jvm.$("<div/>").css("clear", "both"));\n}, jvm.DataSeries = function (params, elements, map) {\n  var scaleConstructor;\n  (params = params || {}).attribute = params.attribute || "fill", this.elements = elements, this.params = params, this.map = map, params.attributes && this.setAttributes(params.attributes), jvm.$.isArray(params.scale) ? (scaleConstructor = "fill" === params.attribute || "stroke" === params.attribute ? jvm.ColorScale : jvm.NumericScale, this.scale = new scaleConstructor(params.scale, params.normalizeFunction, params.min, params.max)) : params.scale ? this.scale = new jvm.OrdinalScale(params.scale) : this.scale = new jvm.SimpleScale(params.scale), this.values = params.values || {}, this.setValues(this.values), this.params.legend && (this.legend = new jvm.Legend(jvm.$.extend({\n    map: this.map,\n    series: this\n  }, this.params.legend)));\n}, jvm.DataSeries.prototype = {\n  setAttributes: function setAttributes(key, attr) {\n    var code,\n        attrs = key;\n    if ("string" == typeof key) this.elements[key] && this.elements[key].setStyle(this.params.attribute, attr);else for (code in attrs) {\n      this.elements[code] && this.elements[code].element.setStyle(this.params.attribute, attrs[code]);\n    }\n  },\n  setValues: function setValues(values) {\n    var val,\n        cc,\n        max = -Number.MAX_VALUE,\n        min = Number.MAX_VALUE,\n        attrs = {};\n    if (this.scale instanceof jvm.OrdinalScale || this.scale instanceof jvm.SimpleScale) for (cc in values) {\n      values[cc] ? attrs[cc] = this.scale.getValue(values[cc]) : attrs[cc] = this.elements[cc].element.style.initial[this.params.attribute];\n    } else {\n      if (void 0 === this.params.min || void 0 === this.params.max) for (cc in values) {\n        max < (val = parseFloat(values[cc])) && (max = val), val < min && (min = val);\n      }\n\n      for (cc in void 0 === this.params.min ? (this.scale.setMin(min), this.params.min = min) : this.scale.setMin(this.params.min), void 0 === this.params.max ? (this.scale.setMax(max), this.params.max = max) : this.scale.setMax(this.params.max), values) {\n        "indexOf" != cc && (val = parseFloat(values[cc]), isNaN(val) ? attrs[cc] = this.elements[cc].element.style.initial[this.params.attribute] : attrs[cc] = this.scale.getValue(val));\n      }\n    }\n    this.setAttributes(attrs), jvm.$.extend(this.values, values);\n  },\n  clear: function clear() {\n    var key,\n        attrs = {};\n\n    for (key in this.values) {\n      this.elements[key] && (attrs[key] = this.elements[key].element.shape.style.initial[this.params.attribute]);\n    }\n\n    this.setAttributes(attrs), this.values = {};\n  },\n  setScale: function setScale(scale) {\n    this.scale.setScale(scale), this.values && this.setValues(this.values);\n  },\n  setNormalizeFunction: function setNormalizeFunction(f) {\n    this.scale.setNormalizeFunction(f), this.values && this.setValues(this.values);\n  }\n}, jvm.Proj = {\n  degRad: 180 / Math.PI,\n  radDeg: Math.PI / 180,\n  radius: 6381372,\n  sgn: function sgn(n) {\n    return 0 < n ? 1 : n < 0 ? -1 : n;\n  },\n  mill: function mill(lat, lng, c) {\n    return {\n      x: this.radius * (lng - c) * this.radDeg,\n      y: -this.radius * Math.log(Math.tan((45 + .4 * lat) * this.radDeg)) / .8\n    };\n  },\n  mill_inv: function mill_inv(x, y, c) {\n    return {\n      lat: (2.5 * Math.atan(Math.exp(.8 * y / this.radius)) - 5 * Math.PI / 8) * this.degRad,\n      lng: (c * this.radDeg + x / this.radius) * this.degRad\n    };\n  },\n  merc: function merc(lat, lng, c) {\n    return {\n      x: this.radius * (lng - c) * this.radDeg,\n      y: -this.radius * Math.log(Math.tan(Math.PI / 4 + lat * Math.PI / 360))\n    };\n  },\n  merc_inv: function merc_inv(x, y, c) {\n    return {\n      lat: (2 * Math.atan(Math.exp(y / this.radius)) - Math.PI / 2) * this.degRad,\n      lng: (c * this.radDeg + x / this.radius) * this.degRad\n    };\n  },\n  aea: function aea(lat, lng, c) {\n    var lambda0 = c * this.radDeg,\n        fi1 = 29.5 * this.radDeg,\n        fi2 = 45.5 * this.radDeg,\n        fi = lat * this.radDeg,\n        lambda = lng * this.radDeg,\n        n = (Math.sin(fi1) + Math.sin(fi2)) / 2,\n        C = Math.cos(fi1) * Math.cos(fi1) + 2 * n * Math.sin(fi1),\n        theta = n * (lambda - lambda0),\n        ro = Math.sqrt(C - 2 * n * Math.sin(fi)) / n,\n        ro0 = Math.sqrt(C - 2 * n * Math.sin(0)) / n;\n    return {\n      x: ro * Math.sin(theta) * this.radius,\n      y: -(ro0 - ro * Math.cos(theta)) * this.radius\n    };\n  },\n  aea_inv: function aea_inv(xCoord, yCoord, c) {\n    var x = xCoord / this.radius,\n        y = yCoord / this.radius,\n        lambda0 = c * this.radDeg,\n        fi1 = 29.5 * this.radDeg,\n        fi2 = 45.5 * this.radDeg,\n        n = (Math.sin(fi1) + Math.sin(fi2)) / 2,\n        C = Math.cos(fi1) * Math.cos(fi1) + 2 * n * Math.sin(fi1),\n        ro0 = Math.sqrt(C - 2 * n * Math.sin(0)) / n,\n        ro = Math.sqrt(x * x + (ro0 - y) * (ro0 - y)),\n        theta = Math.atan(x / (ro0 - y));\n    return {\n      lat: Math.asin((C - ro * ro * n * n) / (2 * n)) * this.degRad,\n      lng: (lambda0 + theta / n) * this.degRad\n    };\n  },\n  lcc: function lcc(lat, lng, c) {\n    var lambda0 = c * this.radDeg,\n        lambda = lng * this.radDeg,\n        fi1 = 33 * this.radDeg,\n        fi2 = 45 * this.radDeg,\n        fi = lat * this.radDeg,\n        n = Math.log(Math.cos(fi1) * (1 / Math.cos(fi2))) / Math.log(Math.tan(Math.PI / 4 + fi2 / 2) * (1 / Math.tan(Math.PI / 4 + fi1 / 2))),\n        F = Math.cos(fi1) * Math.pow(Math.tan(Math.PI / 4 + fi1 / 2), n) / n,\n        ro = F * Math.pow(1 / Math.tan(Math.PI / 4 + fi / 2), n),\n        ro0 = F * Math.pow(1 / Math.tan(Math.PI / 4 + 0), n);\n    return {\n      x: ro * Math.sin(n * (lambda - lambda0)) * this.radius,\n      y: -(ro0 - ro * Math.cos(n * (lambda - lambda0))) * this.radius\n    };\n  },\n  lcc_inv: function lcc_inv(xCoord, yCoord, c) {\n    var x = xCoord / this.radius,\n        y = yCoord / this.radius,\n        lambda0 = c * this.radDeg,\n        fi1 = 33 * this.radDeg,\n        fi2 = 45 * this.radDeg,\n        n = Math.log(Math.cos(fi1) * (1 / Math.cos(fi2))) / Math.log(Math.tan(Math.PI / 4 + fi2 / 2) * (1 / Math.tan(Math.PI / 4 + fi1 / 2))),\n        F = Math.cos(fi1) * Math.pow(Math.tan(Math.PI / 4 + fi1 / 2), n) / n,\n        ro0 = F * Math.pow(1 / Math.tan(Math.PI / 4 + 0), n),\n        ro = this.sgn(n) * Math.sqrt(x * x + (ro0 - y) * (ro0 - y)),\n        theta = Math.atan(x / (ro0 - y));\n    return {\n      lat: (2 * Math.atan(Math.pow(F / ro, 1 / n)) - Math.PI / 2) * this.degRad,\n      lng: (lambda0 + theta / n) * this.degRad\n    };\n  }\n}, jvm.MapObject = function (config) {}, jvm.MapObject.prototype.getLabelText = function (key) {\n  return this.config.label ? "function" == typeof this.config.label.render ? this.config.label.render(key) : key : null;\n}, jvm.MapObject.prototype.getLabelOffsets = function (key) {\n  var offsets;\n  return this.config.label && ("function" == typeof this.config.label.offsets ? offsets = this.config.label.offsets(key) : "object" == _typeof(this.config.label.offsets) && (offsets = this.config.label.offsets[key])), offsets || [0, 0];\n}, jvm.MapObject.prototype.setHovered = function (isHovered) {\n  this.isHovered !== isHovered && (this.isHovered = isHovered, this.shape.isHovered = isHovered, this.shape.updateStyle(), this.label && (this.label.isHovered = isHovered, this.label.updateStyle()));\n}, jvm.MapObject.prototype.setSelected = function (isSelected) {\n  this.isSelected !== isSelected && (this.isSelected = isSelected, this.shape.isSelected = isSelected, this.shape.updateStyle(), this.label && (this.label.isSelected = isSelected, this.label.updateStyle()), jvm.$(this.shape).trigger("selected", [isSelected]));\n}, jvm.MapObject.prototype.setStyle = function () {\n  this.shape.setStyle.apply(this.shape, arguments);\n}, jvm.MapObject.prototype.remove = function () {\n  this.shape.remove(), this.label && this.label.remove();\n}, jvm.Region = function (config) {\n  var bbox, text, offsets;\n  this.config = config, this.map = this.config.map, this.shape = config.canvas.addPath({\n    d: config.path,\n    "data-code": config.code\n  }, config.style, config.canvas.rootElement), this.shape.addClass("jvectormap-region jvectormap-element"), bbox = this.shape.getBBox(), text = this.getLabelText(config.code), this.config.label && text && (offsets = this.getLabelOffsets(config.code), this.labelX = bbox.x + bbox.width / 2 + offsets[0], this.labelY = bbox.y + bbox.height / 2 + offsets[1], this.label = config.canvas.addText({\n    text: text,\n    "text-anchor": "middle",\n    "alignment-baseline": "central",\n    x: this.labelX,\n    y: this.labelY,\n    "data-code": config.code\n  }, config.labelStyle, config.labelsGroup), this.label.addClass("jvectormap-region jvectormap-element"));\n}, jvm.inherits(jvm.Region, jvm.MapObject), jvm.Region.prototype.updateLabelPosition = function () {\n  this.label && this.label.set({\n    x: this.labelX * this.map.scale + this.map.transX * this.map.scale,\n    y: this.labelY * this.map.scale + this.map.transY * this.map.scale\n  });\n}, jvm.Marker = function (config) {\n  var text;\n  this.config = config, this.map = this.config.map, this.isImage = !!this.config.style.initial.image, this.createShape(), text = this.getLabelText(config.index), this.config.label && text && (this.offsets = this.getLabelOffsets(config.index), this.labelX = config.cx / this.map.scale - this.map.transX, this.labelY = config.cy / this.map.scale - this.map.transY, this.label = config.canvas.addText({\n    text: text,\n    "data-index": config.index,\n    dy: "0.6ex",\n    x: this.labelX,\n    y: this.labelY\n  }, config.labelStyle, config.labelsGroup), this.label.addClass("jvectormap-marker jvectormap-element"));\n}, jvm.inherits(jvm.Marker, jvm.MapObject), jvm.Marker.prototype.createShape = function () {\n  var that = this;\n  this.shape && this.shape.remove(), this.shape = this.config.canvas[this.isImage ? "addImage" : "addCircle"]({\n    "data-index": this.config.index,\n    cx: this.config.cx,\n    cy: this.config.cy\n  }, this.config.style, this.config.group), this.shape.addClass("jvectormap-marker jvectormap-element"), this.isImage && jvm.$(this.shape.node).on("imageloaded", function () {\n    that.updateLabelPosition();\n  });\n}, jvm.Marker.prototype.updateLabelPosition = function () {\n  this.label && this.label.set({\n    x: this.labelX * this.map.scale + this.offsets[0] + this.map.transX * this.map.scale + 5 + (this.isImage ? (this.shape.width || 0) / 2 : this.shape.properties.r),\n    y: this.labelY * this.map.scale + this.map.transY * this.map.scale + this.offsets[1]\n  });\n}, jvm.Marker.prototype.setStyle = function (property, value) {\n  var isImage;\n  jvm.Marker.parentClass.prototype.setStyle.apply(this, arguments), "r" === property && this.updateLabelPosition(), (isImage = !!this.shape.get("image")) != this.isImage && (this.isImage = isImage, this.config.style = jvm.$.extend(!0, {}, this.shape.style), this.createShape());\n}, jvm.Map = function (params) {\n  var e,\n      map = this;\n  if (this.params = jvm.$.extend(!0, {}, jvm.Map.defaultParams, params), !jvm.Map.maps[this.params.map]) throw new Error("Attempt to use map which was not loaded: " + this.params.map);\n\n  for (e in this.mapData = jvm.Map.maps[this.params.map], this.markers = {}, this.regions = {}, this.regionsColors = {}, this.regionsData = {}, this.container = jvm.$("<div>").addClass("jvectormap-container"), this.params.container && this.params.container.append(this.container), this.container.data("mapObject", this), this.defaultWidth = this.mapData.width, this.defaultHeight = this.mapData.height, this.setBackgroundColor(this.params.backgroundColor), this.onResize = function () {\n    map.updateSize();\n  }, jvm.$(window).resize(this.onResize), jvm.Map.apiEvents) {\n    this.params[e] && this.container.bind(jvm.Map.apiEvents[e] + ".jvectormap", this.params[e]);\n  }\n\n  this.canvas = new jvm.VectorCanvas(this.container[0], this.width, this.height), this.params.bindTouchEvents && ("ontouchstart" in window || window.DocumentTouch && document instanceof DocumentTouch ? this.bindContainerTouchEvents() : window.MSGesture && this.bindContainerPointerEvents()), this.bindContainerEvents(), this.bindElementEvents(), this.createTip(), this.params.zoomButtons && this.bindZoomButtons(), this.createRegions(), this.createMarkers(this.params.markers || {}), this.updateSize(), this.params.focusOn && ("string" == typeof this.params.focusOn ? this.params.focusOn = {\n    region: this.params.focusOn\n  } : jvm.$.isArray(this.params.focusOn) && (this.params.focusOn = {\n    regions: this.params.focusOn\n  }), this.setFocus(this.params.focusOn)), this.params.selectedRegions && this.setSelectedRegions(this.params.selectedRegions), this.params.selectedMarkers && this.setSelectedMarkers(this.params.selectedMarkers), this.legendCntHorizontal = jvm.$("<div/>").addClass("jvectormap-legend-cnt jvectormap-legend-cnt-h"), this.legendCntVertical = jvm.$("<div/>").addClass("jvectormap-legend-cnt jvectormap-legend-cnt-v"), this.container.append(this.legendCntHorizontal), this.container.append(this.legendCntVertical), this.params.series && this.createSeries();\n}, jvm.Map.prototype = {\n  transX: 0,\n  transY: 0,\n  scale: 1,\n  baseTransX: 0,\n  baseTransY: 0,\n  baseScale: 1,\n  width: 0,\n  height: 0,\n  setBackgroundColor: function setBackgroundColor(backgroundColor) {\n    this.container.css("background-color", backgroundColor);\n  },\n  resize: function resize() {\n    var curBaseScale = this.baseScale;\n    this.width / this.height > this.defaultWidth / this.defaultHeight ? (this.baseScale = this.height / this.defaultHeight, this.baseTransX = Math.abs(this.width - this.defaultWidth * this.baseScale) / (2 * this.baseScale)) : (this.baseScale = this.width / this.defaultWidth, this.baseTransY = Math.abs(this.height - this.defaultHeight * this.baseScale) / (2 * this.baseScale)), this.scale *= this.baseScale / curBaseScale, this.transX *= this.baseScale / curBaseScale, this.transY *= this.baseScale / curBaseScale;\n  },\n  updateSize: function updateSize() {\n    this.width = this.container.width(), this.height = this.container.height(), this.resize(), this.canvas.setSize(this.width, this.height), this.applyTransform();\n  },\n  reset: function reset() {\n    var key, i;\n\n    for (key in this.series) {\n      for (i = 0; i < this.series[key].length; i++) {\n        this.series[key][i].clear();\n      }\n    }\n\n    this.scale = this.baseScale, this.transX = this.baseTransX, this.transY = this.baseTransY, this.applyTransform();\n  },\n  applyTransform: function applyTransform() {\n    var maxTransX, maxTransY, minTransX, minTransY;\n    minTransX = this.defaultWidth * this.scale <= this.width ? (maxTransX = (this.width - this.defaultWidth * this.scale) / (2 * this.scale), (this.width - this.defaultWidth * this.scale) / (2 * this.scale)) : (maxTransX = 0, (this.width - this.defaultWidth * this.scale) / this.scale), minTransY = this.defaultHeight * this.scale <= this.height ? (maxTransY = (this.height - this.defaultHeight * this.scale) / (2 * this.scale), (this.height - this.defaultHeight * this.scale) / (2 * this.scale)) : (maxTransY = 0, (this.height - this.defaultHeight * this.scale) / this.scale), this.transY > maxTransY ? this.transY = maxTransY : this.transY < minTransY && (this.transY = minTransY), this.transX > maxTransX ? this.transX = maxTransX : this.transX < minTransX && (this.transX = minTransX), this.canvas.applyTransformParams(this.scale, this.transX, this.transY), this.markers && this.repositionMarkers(), this.repositionLabels(), this.container.trigger("viewportChange", [this.scale / this.baseScale, this.transX, this.transY]);\n  },\n  bindContainerEvents: function bindContainerEvents() {\n    var oldPageX,\n        oldPageY,\n        mouseDown = !1,\n        map = this;\n    this.params.panOnDrag && (this.container.mousemove(function (e) {\n      return mouseDown && (map.transX -= (oldPageX - e.pageX) / map.scale, map.transY -= (oldPageY - e.pageY) / map.scale, map.applyTransform(), oldPageX = e.pageX, oldPageY = e.pageY), !1;\n    }).mousedown(function (e) {\n      return mouseDown = !0, oldPageX = e.pageX, oldPageY = e.pageY, !1;\n    }), this.onContainerMouseUp = function () {\n      mouseDown = !1;\n    }, jvm.$("body").mouseup(this.onContainerMouseUp)), this.params.zoomOnScroll && this.container.mousewheel(function (event, delta, deltaX, deltaY) {\n      var offset = jvm.$(map.container).offset(),\n          centerX = event.pageX - offset.left,\n          centerY = event.pageY - offset.top,\n          zoomStep = Math.pow(1 + map.params.zoomOnScrollSpeed / 1e3, event.deltaFactor * event.deltaY);\n      map.tip.hide(), map.setScale(map.scale * zoomStep, centerX, centerY), event.preventDefault();\n    });\n  },\n  bindContainerTouchEvents: function bindContainerTouchEvents() {\n    function handleTouchEvent(e) {\n      var offset,\n          scale,\n          transXOld,\n          transYOld,\n          touches = e.originalEvent.touches;\n      "touchstart" == e.type && (lastTouchesLength = 0), 1 == touches.length ? (1 == lastTouchesLength && (transXOld = map.transX, transYOld = map.transY, map.transX -= (touchX - touches[0].pageX) / map.scale, map.transY -= (touchY - touches[0].pageY) / map.scale, map.applyTransform(), map.tip.hide(), transXOld == map.transX && transYOld == map.transY || e.preventDefault()), touchX = touches[0].pageX, touchY = touches[0].pageY) : 2 == touches.length && (2 == lastTouchesLength ? (scale = Math.sqrt(Math.pow(touches[0].pageX - touches[1].pageX, 2) + Math.pow(touches[0].pageY - touches[1].pageY, 2)) / touchStartDistance, map.setScale(touchStartScale * scale, centerTouchX, centerTouchY), map.tip.hide(), e.preventDefault()) : (offset = jvm.$(map.container).offset(), centerTouchX = touches[0].pageX > touches[1].pageX ? touches[1].pageX + (touches[0].pageX - touches[1].pageX) / 2 : touches[0].pageX + (touches[1].pageX - touches[0].pageX) / 2, centerTouchY = touches[0].pageY > touches[1].pageY ? touches[1].pageY + (touches[0].pageY - touches[1].pageY) / 2 : touches[0].pageY + (touches[1].pageY - touches[0].pageY) / 2, centerTouchX -= offset.left, centerTouchY -= offset.top, touchStartScale = map.scale, touchStartDistance = Math.sqrt(Math.pow(touches[0].pageX - touches[1].pageX, 2) + Math.pow(touches[0].pageY - touches[1].pageY, 2)))), lastTouchesLength = touches.length;\n    }\n\n    var touchStartScale,\n        touchStartDistance,\n        touchX,\n        touchY,\n        centerTouchX,\n        centerTouchY,\n        lastTouchesLength,\n        map = this;\n    jvm.$(this.container).bind("touchstart", handleTouchEvent), jvm.$(this.container).bind("touchmove", handleTouchEvent);\n  },\n  bindContainerPointerEvents: function bindContainerPointerEvents() {\n    var map = this,\n        gesture = new MSGesture(),\n        element = this.container[0];\n    (gesture.target = element).addEventListener("MSGestureChange", function (e) {\n      var transXOld, transYOld;\n      0 == e.translationX && 0 == e.translationY || (transXOld = map.transX, transYOld = map.transY, map.transX += e.translationX / map.scale, map.transY += e.translationY / map.scale, map.applyTransform(), map.tip.hide(), transXOld == map.transX && transYOld == map.transY || e.preventDefault()), 1 != e.scale && (map.setScale(map.scale * e.scale, e.offsetX, e.offsetY), map.tip.hide(), e.preventDefault());\n    }, !1), element.addEventListener("pointerdown", function (e) {\n      gesture.addPointer(e.pointerId);\n    }, !1);\n  },\n  bindElementEvents: function bindElementEvents() {\n    var pageX,\n        pageY,\n        mouseMoved,\n        map = this;\n    this.container.mousemove(function (e) {\n      2 < Math.abs(pageX - e.pageX) + Math.abs(pageY - e.pageY) && (mouseMoved = !0);\n    }), this.container.delegate("[class~=\'jvectormap-element\']", "mouseover mouseout", function (e) {\n      var type = -1 === (jvm.$(this).attr("class").baseVal || jvm.$(this).attr("class")).indexOf("jvectormap-region") ? "marker" : "region",\n          code = "region" == type ? jvm.$(this).attr("data-code") : jvm.$(this).attr("data-index"),\n          element = "region" == type ? map.regions[code].element : map.markers[code].element,\n          tipText = "region" == type ? map.mapData.paths[code].name : map.markers[code].config.name || "",\n          tipShowEvent = jvm.$.Event(type + "TipShow.jvectormap"),\n          overEvent = jvm.$.Event(type + "Over.jvectormap");\n      "mouseover" == e.type ? (map.container.trigger(overEvent, [code]), overEvent.isDefaultPrevented() || element.setHovered(!0), map.tip.text(tipText), map.container.trigger(tipShowEvent, [map.tip, code]), tipShowEvent.isDefaultPrevented() || (map.tip.show(), map.tipWidth = map.tip.width(), map.tipHeight = map.tip.height())) : (element.setHovered(!1), map.tip.hide(), map.container.trigger(type + "Out.jvectormap", [code]));\n    }), this.container.delegate("[class~=\'jvectormap-element\']", "mousedown", function (e) {\n      pageX = e.pageX, pageY = e.pageY, mouseMoved = !1;\n    }), this.container.delegate("[class~=\'jvectormap-element\']", "mouseup", function () {\n      var type = -1 === (jvm.$(this).attr("class").baseVal ? jvm.$(this).attr("class").baseVal : jvm.$(this).attr("class")).indexOf("jvectormap-region") ? "marker" : "region",\n          code = "region" == type ? jvm.$(this).attr("data-code") : jvm.$(this).attr("data-index"),\n          clickEvent = jvm.$.Event(type + "Click.jvectormap"),\n          element = "region" == type ? map.regions[code].element : map.markers[code].element;\n      mouseMoved || (map.container.trigger(clickEvent, [code]), ("region" == type && map.params.regionsSelectable || "marker" == type && map.params.markersSelectable) && (clickEvent.isDefaultPrevented() || (map.params[type + "sSelectableOne"] && map.clearSelected(type + "s"), element.setSelected(!element.isSelected))));\n    });\n  },\n  bindZoomButtons: function bindZoomButtons() {\n    var map = this;\n    jvm.$("<div/>").addClass("jvectormap-zoomin").text("+").appendTo(this.container), jvm.$("<div/>").addClass("jvectormap-zoomout").html("&#x2212;").appendTo(this.container), this.container.find(".jvectormap-zoomin").click(function () {\n      map.setScale(map.scale * map.params.zoomStep, map.width / 2, map.height / 2, !1, map.params.zoomAnimate);\n    }), this.container.find(".jvectormap-zoomout").click(function () {\n      map.setScale(map.scale / map.params.zoomStep, map.width / 2, map.height / 2, !1, map.params.zoomAnimate);\n    });\n  },\n  createTip: function createTip() {\n    var map = this;\n    this.tip = jvm.$("<div/>").addClass("jvectormap-tip").appendTo(jvm.$("body")), this.container.mousemove(function (e) {\n      var left = e.pageX - 15 - map.tipWidth,\n          top = e.pageY - 15 - map.tipHeight;\n      left < 5 && (left = e.pageX + 15), top < 5 && (top = e.pageY + 15), map.tip.css({\n        left: left,\n        top: top\n      });\n    });\n  },\n  setScale: function setScale(scale, anchorX, anchorY, isCentered, animate) {\n    var interval,\n        scaleStart,\n        scaleDiff,\n        transXStart,\n        transXDiff,\n        transYStart,\n        transYDiff,\n        transX,\n        transY,\n        viewportChangeEvent = jvm.$.Event("zoom.jvectormap"),\n        that = this,\n        i = 0,\n        count = Math.abs(Math.round(60 * (scale - this.scale) / Math.max(scale, this.scale))),\n        deferred = new jvm.$.Deferred();\n    return scale > this.params.zoomMax * this.baseScale ? scale = this.params.zoomMax * this.baseScale : scale < this.params.zoomMin * this.baseScale && (scale = this.params.zoomMin * this.baseScale), void 0 !== anchorX && void 0 !== anchorY && (zoomStep = scale / this.scale, transY = isCentered ? (transX = anchorX + this.defaultWidth * (this.width / (this.defaultWidth * scale)) / 2, anchorY + this.defaultHeight * (this.height / (this.defaultHeight * scale)) / 2) : (transX = this.transX - (zoomStep - 1) / scale * anchorX, this.transY - (zoomStep - 1) / scale * anchorY)), animate && 0 < count ? (scaleStart = this.scale, scaleDiff = (scale - scaleStart) / count, transXStart = this.transX * this.scale, transYStart = this.transY * this.scale, transXDiff = (transX * scale - transXStart) / count, transYDiff = (transY * scale - transYStart) / count, interval = setInterval(function () {\n      i += 1, that.scale = scaleStart + scaleDiff * i, that.transX = (transXStart + transXDiff * i) / that.scale, that.transY = (transYStart + transYDiff * i) / that.scale, that.applyTransform(), i == count && (clearInterval(interval), that.container.trigger(viewportChangeEvent, [scale / that.baseScale]), deferred.resolve());\n    }, 10)) : (this.transX = transX, this.transY = transY, this.scale = scale, this.applyTransform(), this.container.trigger(viewportChangeEvent, [scale / this.baseScale]), deferred.resolve()), deferred;\n  },\n  setFocus: function setFocus(config) {\n    var bbox, itemBbox, codes, i, point;\n\n    if ((config = config || {}).region ? codes = [config.region] : config.regions && (codes = config.regions), codes) {\n      for (i = 0; i < codes.length; i++) {\n        this.regions[codes[i]] && (itemBbox = this.regions[codes[i]].element.shape.getBBox()) && (bbox = void 0 === bbox ? itemBbox : {\n          x: Math.min(bbox.x, itemBbox.x),\n          y: Math.min(bbox.y, itemBbox.y),\n          width: Math.max(bbox.x + bbox.width, itemBbox.x + itemBbox.width) - Math.min(bbox.x, itemBbox.x),\n          height: Math.max(bbox.y + bbox.height, itemBbox.y + itemBbox.height) - Math.min(bbox.y, itemBbox.y)\n        });\n      }\n\n      return this.setScale(Math.min(this.width / bbox.width, this.height / bbox.height), -(bbox.x + bbox.width / 2), -(bbox.y + bbox.height / 2), !0, config.animate);\n    }\n\n    return void 0 !== config.lat && void 0 !== config.lng ? (point = this.latLngToPoint(config.lat, config.lng), config.x = this.transX - point.x / this.scale, config.y = this.transY - point.y / this.scale) : config.x && config.y && (config.x *= -this.defaultWidth, config.y *= -this.defaultHeight), this.setScale(config.scale * this.baseScale, config.x, config.y, !0, config.animate);\n  },\n  getSelected: function getSelected(type) {\n    var key,\n        selected = [];\n\n    for (key in this[type]) {\n      this[type][key].element.isSelected && selected.push(key);\n    }\n\n    return selected;\n  },\n  getSelectedRegions: function getSelectedRegions() {\n    return this.getSelected("regions");\n  },\n  getSelectedMarkers: function getSelectedMarkers() {\n    return this.getSelected("markers");\n  },\n  setSelected: function setSelected(type, keys) {\n    var i;\n    if ("object" != _typeof(keys) && (keys = [keys]), jvm.$.isArray(keys)) for (i = 0; i < keys.length; i++) {\n      this[type][keys[i]].element.setSelected(!0);\n    } else for (i in keys) {\n      this[type][i].element.setSelected(!!keys[i]);\n    }\n  },\n  setSelectedRegions: function setSelectedRegions(keys) {\n    this.setSelected("regions", keys);\n  },\n  setSelectedMarkers: function setSelectedMarkers(keys) {\n    this.setSelected("markers", keys);\n  },\n  clearSelected: function clearSelected(type) {\n    var i,\n        select = {},\n        selected = this.getSelected(type);\n\n    for (i = 0; i < selected.length; i++) {\n      select[selected[i]] = !1;\n    }\n\n    this.setSelected(type, select);\n  },\n  clearSelectedRegions: function clearSelectedRegions() {\n    this.clearSelected("regions");\n  },\n  clearSelectedMarkers: function clearSelectedMarkers() {\n    this.clearSelected("markers");\n  },\n  getMapObject: function getMapObject() {\n    return this;\n  },\n  getRegionName: function getRegionName(code) {\n    return this.mapData.paths[code].name;\n  },\n  createRegions: function createRegions() {\n    var key,\n        region,\n        map = this;\n\n    for (key in this.regionLabelsGroup = this.regionLabelsGroup || this.canvas.addGroup(), this.mapData.paths) {\n      region = new jvm.Region({\n        map: this,\n        path: this.mapData.paths[key].path,\n        code: key,\n        style: jvm.$.extend(!0, {}, this.params.regionStyle),\n        labelStyle: jvm.$.extend(!0, {}, this.params.regionLabelStyle),\n        canvas: this.canvas,\n        labelsGroup: this.regionLabelsGroup,\n        label: "vml" != this.canvas.mode ? this.params.labels && this.params.labels.regions : null\n      }), jvm.$(region.shape).bind("selected", function (e, isSelected) {\n        map.container.trigger("regionSelected.jvectormap", [jvm.$(this.node).attr("data-code"), isSelected, map.getSelectedRegions()]);\n      }), this.regions[key] = {\n        element: region,\n        config: this.mapData.paths[key]\n      };\n    }\n  },\n  createMarkers: function createMarkers(markers) {\n    var i,\n        marker,\n        point,\n        markerConfig,\n        markersArray,\n        map = this;\n    if (this.markersGroup = this.markersGroup || this.canvas.addGroup(), this.markerLabelsGroup = this.markerLabelsGroup || this.canvas.addGroup(), jvm.$.isArray(markers)) for (markersArray = markers.slice(), markers = {}, i = 0; i < markersArray.length; i++) {\n      markers[i] = markersArray[i];\n    }\n\n    for (i in markers) {\n      markerConfig = markers[i] instanceof Array ? {\n        latLng: markers[i]\n      } : markers[i], !1 !== (point = this.getMarkerPosition(markerConfig)) && (marker = new jvm.Marker({\n        map: this,\n        style: jvm.$.extend(!0, {}, this.params.markerStyle, {\n          initial: markerConfig.style || {}\n        }),\n        labelStyle: jvm.$.extend(!0, {}, this.params.markerLabelStyle),\n        index: i,\n        cx: point.x,\n        cy: point.y,\n        group: this.markersGroup,\n        canvas: this.canvas,\n        labelsGroup: this.markerLabelsGroup,\n        label: "vml" != this.canvas.mode ? this.params.labels && this.params.labels.markers : null\n      }), jvm.$(marker.shape).bind("selected", function (e, isSelected) {\n        map.container.trigger("markerSelected.jvectormap", [jvm.$(this.node).attr("data-index"), isSelected, map.getSelectedMarkers()]);\n      }), this.markers[i] && this.removeMarkers([i]), this.markers[i] = {\n        element: marker,\n        config: markerConfig\n      });\n    }\n  },\n  repositionMarkers: function repositionMarkers() {\n    var i, point;\n\n    for (i in this.markers) {\n      !1 !== (point = this.getMarkerPosition(this.markers[i].config)) && this.markers[i].element.setStyle({\n        cx: point.x,\n        cy: point.y\n      });\n    }\n  },\n  repositionLabels: function repositionLabels() {\n    var key;\n\n    for (key in this.regions) {\n      this.regions[key].element.updateLabelPosition();\n    }\n\n    for (key in this.markers) {\n      this.markers[key].element.updateLabelPosition();\n    }\n  },\n  getMarkerPosition: function getMarkerPosition(markerConfig) {\n    return jvm.Map.maps[this.params.map].projection ? this.latLngToPoint.apply(this, markerConfig.latLng || [0, 0]) : {\n      x: markerConfig.coords[0] * this.scale + this.transX * this.scale,\n      y: markerConfig.coords[1] * this.scale + this.transY * this.scale\n    };\n  },\n  addMarker: function addMarker(key, marker, seriesData) {\n    var values,\n        i,\n        markers = {},\n        data = [];\n    seriesData = seriesData || [];\n\n    for (markers[key] = marker, i = 0; i < seriesData.length; i++) {\n      values = {}, void 0 !== seriesData[i] && (values[key] = seriesData[i]), data.push(values);\n    }\n\n    this.addMarkers(markers, data);\n  },\n  addMarkers: function addMarkers(markers, seriesData) {\n    var i;\n\n    for (seriesData = seriesData || [], this.createMarkers(markers), i = 0; i < seriesData.length; i++) {\n      this.series.markers[i].setValues(seriesData[i] || {});\n    }\n  },\n  removeMarkers: function removeMarkers(markers) {\n    var i;\n\n    for (i = 0; i < markers.length; i++) {\n      this.markers[markers[i]].element.remove(), delete this.markers[markers[i]];\n    }\n  },\n  removeAllMarkers: function removeAllMarkers() {\n    var i,\n        markers = [];\n\n    for (i in this.markers) {\n      markers.push(i);\n    }\n\n    this.removeMarkers(markers);\n  },\n  latLngToPoint: function latLngToPoint(lat, lng) {\n    var point,\n        inset,\n        bbox,\n        proj = jvm.Map.maps[this.params.map].projection,\n        centralMeridian = proj.centralMeridian;\n    return lng < -180 + centralMeridian && (lng += 360), point = jvm.Proj[proj.type](lat, lng, centralMeridian), !!(inset = this.getInsetForPoint(point.x, point.y)) && (bbox = inset.bbox, point.x = (point.x - bbox[0].x) / (bbox[1].x - bbox[0].x) * inset.width * this.scale, point.y = (point.y - bbox[0].y) / (bbox[1].y - bbox[0].y) * inset.height * this.scale, {\n      x: point.x + this.transX * this.scale + inset.left * this.scale,\n      y: point.y + this.transY * this.scale + inset.top * this.scale\n    });\n  },\n  pointToLatLng: function pointToLatLng(x, y) {\n    var i,\n        inset,\n        bbox,\n        nx,\n        ny,\n        proj = jvm.Map.maps[this.params.map].projection,\n        centralMeridian = proj.centralMeridian,\n        insets = jvm.Map.maps[this.params.map].insets;\n\n    for (i = 0; i < insets.length; i++) {\n      if (bbox = (inset = insets[i]).bbox, nx = x - (this.transX * this.scale + inset.left * this.scale), ny = y - (this.transY * this.scale + inset.top * this.scale), nx = nx / (inset.width * this.scale) * (bbox[1].x - bbox[0].x) + bbox[0].x, ny = ny / (inset.height * this.scale) * (bbox[1].y - bbox[0].y) + bbox[0].y, nx > bbox[0].x && nx < bbox[1].x && ny > bbox[0].y && ny < bbox[1].y) return jvm.Proj[proj.type + "_inv"](nx, -ny, centralMeridian);\n    }\n\n    return !1;\n  },\n  getInsetForPoint: function getInsetForPoint(x, y) {\n    var i,\n        bbox,\n        insets = jvm.Map.maps[this.params.map].insets;\n\n    for (i = 0; i < insets.length; i++) {\n      if (x > (bbox = insets[i].bbox)[0].x && x < bbox[1].x && y > bbox[0].y && y < bbox[1].y) return insets[i];\n    }\n  },\n  createSeries: function createSeries() {\n    var i, key;\n\n    for (key in this.series = {\n      markers: [],\n      regions: []\n    }, this.params.series) {\n      for (i = 0; i < this.params.series[key].length; i++) {\n        this.series[key][i] = new jvm.DataSeries(this.params.series[key][i], this[key], this);\n      }\n    }\n  },\n  remove: function remove() {\n    this.tip.remove(), this.container.remove(), jvm.$(window).unbind("resize", this.onResize), jvm.$("body").unbind("mouseup", this.onContainerMouseUp);\n  }\n}, jvm.Map.maps = {}, jvm.Map.defaultParams = {\n  map: "world_mill_en",\n  backgroundColor: "#505050",\n  zoomButtons: !0,\n  zoomOnScroll: !0,\n  zoomOnScrollSpeed: 3,\n  panOnDrag: !0,\n  zoomMax: 8,\n  zoomMin: 1,\n  zoomStep: 1.6,\n  zoomAnimate: !0,\n  regionsSelectable: !1,\n  markersSelectable: !1,\n  bindTouchEvents: !0,\n  regionStyle: {\n    initial: {\n      fill: "white",\n      "fill-opacity": 1,\n      stroke: "none",\n      "stroke-width": 0,\n      "stroke-opacity": 1\n    },\n    hover: {\n      "fill-opacity": .8,\n      cursor: "pointer"\n    },\n    selected: {\n      fill: "yellow"\n    },\n    selectedHover: {}\n  },\n  regionLabelStyle: {\n    initial: {\n      "font-family": "Verdana",\n      "font-size": "12",\n      "font-weight": "bold",\n      cursor: "default",\n      fill: "black"\n    },\n    hover: {\n      cursor: "pointer"\n    }\n  },\n  markerStyle: {\n    initial: {\n      fill: "grey",\n      stroke: "#505050",\n      "fill-opacity": 1,\n      "stroke-width": 1,\n      "stroke-opacity": 1,\n      r: 5\n    },\n    hover: {\n      stroke: "black",\n      "stroke-width": 2,\n      cursor: "pointer"\n    },\n    selected: {\n      fill: "blue"\n    },\n    selectedHover: {}\n  },\n  markerLabelStyle: {\n    initial: {\n      "font-family": "Verdana",\n      "font-size": "12",\n      "font-weight": "bold",\n      cursor: "default",\n      fill: "black"\n    },\n    hover: {\n      cursor: "pointer"\n    }\n  }\n}, jvm.Map.apiEvents = {\n  onRegionTipShow: "regionTipShow",\n  onRegionOver: "regionOver",\n  onRegionOut: "regionOut",\n  onRegionClick: "regionClick",\n  onRegionSelected: "regionSelected",\n  onMarkerTipShow: "markerTipShow",\n  onMarkerOver: "markerOver",\n  onMarkerOut: "markerOut",\n  onMarkerClick: "markerClick",\n  onMarkerSelected: "markerSelected",\n  onViewportChange: "viewportChange"\n}, jvm.MultiMap = function (params) {\n  var that = this;\n  this.maps = {}, this.params = jvm.$.extend(!0, {}, jvm.MultiMap.defaultParams, params), this.params.maxLevel = this.params.maxLevel || Number.MAX_VALUE, this.params.main = this.params.main || {}, this.params.main.multiMapLevel = 0, this.history = [this.addMap(this.params.main.map, this.params.main)], this.defaultProjection = this.history[0].mapData.projection.type, this.mapsLoaded = {}, this.params.container.css({\n    position: "relative"\n  }), this.backButton = jvm.$("<div/>").addClass("jvectormap-goback").text("Back").appendTo(this.params.container), this.backButton.hide(), this.backButton.click(function () {\n    that.goBack();\n  }), this.spinner = jvm.$("<div/>").addClass("jvectormap-spinner").appendTo(this.params.container), this.spinner.hide();\n}, jvm.MultiMap.prototype = {\n  addMap: function addMap(name, config) {\n    var cnt = jvm.$("<div/>").css({\n      width: "100%",\n      height: "100%"\n    });\n    return this.params.container.append(cnt), this.maps[name] = new jvm.Map(jvm.$.extend(config, {\n      container: cnt\n    })), this.params.maxLevel > config.multiMapLevel && this.maps[name].container.on("regionClick.jvectormap", {\n      scope: this\n    }, function (e, code) {\n      var multimap = e.data.scope,\n          mapName = multimap.params.mapNameByCode(code, multimap);\n      multimap.drillDownPromise && "pending" === multimap.drillDownPromise.state() || multimap.drillDown(mapName, code);\n    }), this.maps[name];\n  },\n  downloadMap: function downloadMap(code) {\n    var that = this,\n        deferred = jvm.$.Deferred();\n    return this.mapsLoaded[code] ? deferred.resolve() : jvm.$.get(this.params.mapUrlByCode(code, this)).then(function () {\n      that.mapsLoaded[code] = !0, deferred.resolve();\n    }, function () {\n      deferred.reject();\n    }), deferred;\n  },\n  drillDown: function drillDown(name, code) {\n    var currentMap = this.history[this.history.length - 1],\n        that = this,\n        focusPromise = currentMap.setFocus({\n      region: code,\n      animate: !0\n    }),\n        downloadPromise = this.downloadMap(code);\n    focusPromise.then(function () {\n      "pending" === downloadPromise.state() && that.spinner.show();\n    }), downloadPromise.always(function () {\n      that.spinner.hide();\n    }), this.drillDownPromise = jvm.$.when(downloadPromise, focusPromise), this.drillDownPromise.then(function () {\n      currentMap.params.container.hide(), that.maps[name] ? that.maps[name].params.container.show() : that.addMap(name, {\n        map: name,\n        multiMapLevel: currentMap.params.multiMapLevel + 1\n      }), that.history.push(that.maps[name]), that.backButton.show();\n    });\n  },\n  goBack: function goBack() {\n    var currentMap = this.history.pop(),\n        prevMap = this.history[this.history.length - 1],\n        that = this;\n    currentMap.setFocus({\n      scale: 1,\n      x: .5,\n      y: .5,\n      animate: !0\n    }).then(function () {\n      currentMap.params.container.hide(), prevMap.params.container.show(), prevMap.updateSize(), 1 === that.history.length && that.backButton.hide(), prevMap.setFocus({\n        scale: 1,\n        x: .5,\n        y: .5,\n        animate: !0\n      });\n    });\n  }\n}, jvm.MultiMap.defaultParams = {\n  mapNameByCode: function mapNameByCode(code, multiMap) {\n    return code.toLowerCase() + "_" + multiMap.defaultProjection + "_en";\n  },\n  mapUrlByCode: function mapUrlByCode(code, multiMap) {\n    return "jquery-jvectormap-data-" + code.toLowerCase() + "-" + multiMap.defaultProjection + "-en.js";\n  }\n};'}}]);